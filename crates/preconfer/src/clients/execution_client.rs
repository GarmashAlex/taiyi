use alloy_consensus::{Header, TxEnvelope};
use alloy_eips::BlockId;
use alloy_primitives::{
    hex::FromHex, keccak256, private::alloy_rlp::Decodable, Address, StorageKey, B256, U256,
};
use alloy_provider::{ext::DebugApi, Provider, ProviderBuilder, RootProvider};
use alloy_rpc_types::StateContext;
use alloy_rpc_types_trace::geth::GethDebugTracingCallOptions;
use alloy_sol_types::sol;
use alloy_transport_http::Http;
use k256::pkcs8::der;
use lazy_static::lazy_static;
use reqwest::{Client, Url};

sol! {
    #[sol(rpc)]
    contract TaiyiEscrow {
        #[derive(Debug)]
        function balanceOf(address user) public view returns (uint256);

        #[derive(Debug)]
        function deposit() public payable;
    }
}

#[derive(Clone, Debug)]
pub struct ExecutionClient {
    inner: RootProvider<Http<Client>>,
}

impl ExecutionClient {
    pub fn new(rpc_url: Url) -> Self {
        ExecutionClient { inner: ProviderBuilder::new().on_http(rpc_url) }
    }

    pub async fn get_account_state(&self, address: Address) -> eyre::Result<AccountState> {
        let account = self.inner.get_account(address).await?;
        Ok(AccountState { nonce: account.nonce, balance: account.balance })
    }

    pub async fn base_fee(&self) -> eyre::Result<u128> {
        let fees = self.inner.estimate_eip1559_fees(None).await?;
        Ok(fees.max_fee_per_gas)
    }

    /// Get the balance of an account in the escrow contract.
    ///
    /// * `escrow` - The escrow contract address.
    /// * `account`-  The account address to get the balance of.
    pub async fn escrow_balance(&self, escrow: Address, account: Address) -> eyre::Result<U256> {
        // mapping slots are generated by hashing the key concatenated with the storage index.
        let storage_key = keccak256(format!("{}{}", account, *BALANCE_STORAGE_SLOT));
        let resutl =
            self.inner.get_storage_at(escrow, storage_key.into()).await.unwrap_or_default();
        Ok(resutl)
    }

    pub async fn balance_of(
        &self,
        account: Address,
        taiyi_escrow_address: Address,
    ) -> eyre::Result<U256> {
        let taiyi_escrow = TaiyiEscrow::new(taiyi_escrow_address, self.inner.clone());
        let balance = taiyi_escrow.balanceOf(account).call().await?;
        Ok(balance._0)
    }

    pub async fn gas_used(&self, tx: TxEnvelope) -> eyre::Result<u64> {
        let trace_options = GethDebugTracingCallOptions::default();
        let trace = self
            .inner
            .debug_trace_call(tx.into(), BlockId::latest(), trace_options)
            .await?
            .try_into_default_frame()?;
        Ok(trace.gas)
    }

    pub async fn header(&self, block: B256) -> eyre::Result<Header> {
        let rlp_encoded_header =
            self.inner.debug_get_raw_header(BlockId::Hash(block.into())).await?;
        let decoded = Header::decode(&mut rlp_encoded_header.as_ref())?;
        Ok(decoded)
    }

    pub async fn nonce(&self, address: Address) -> eyre::Result<u64> {
        let account = self.inner.get_account(address).await?;
        Ok(account.nonce)
    }
}

lazy_static! {
    // TODO: Correct value of BALANCE_STORAGE_SLOT
    /// mapping(address => uint256) public balances
    pub static ref BALANCE_STORAGE_SLOT: StorageKey =
        StorageKey::from_hex("0x0000000000000000000000000000000000000000000000000000000000000001").expect("");
}

#[derive(Debug, Clone)]
pub struct AccountState {
    pub nonce: u64,
    pub balance: U256,
}

mod test {
    use alloy_consensus::TxEnvelope;
    use alloy_eips::BlockId;
    use alloy_network::{EthereumWallet, TransactionBuilder};
    use alloy_primitives::U256;
    use alloy_provider::ext::DebugApi;
    use alloy_rpc_types::TransactionRequest;
    use alloy_rpc_types_trace::geth::GethDebugTracingCallOptions;
    use alloy_signer_local::PrivateKeySigner;

    use crate::clients::execution_client::ExecutionClient;

    #[tokio::test]
    async fn test_gas_used() -> eyre::Result<()> {
        let anvil = alloy_node_bindings::Anvil::new().block_time(1).chain_id(0).spawn();
        let rpc_url = anvil.endpoint();
        let sender = anvil.addresses().first().unwrap();
        let receiver = anvil.addresses().last().unwrap();
        let client = ExecutionClient::new(rpc_url.parse().unwrap());
        let sender_pk = anvil.keys().first().unwrap();
        let signer = PrivateKeySigner::from_signing_key(sender_pk.into());
        let wallet = EthereumWallet::from(signer.clone());

        let tx = TransactionRequest::default()
            .with_from(*sender)
            .with_to(*receiver)
            .with_value(U256::from(100))
            .with_nonce(0)
            .with_gas_limit(30_000)
            .with_max_fee_per_gas(1)
            .with_max_priority_fee_per_gas(1)
            .build(&wallet)
            .await?;

        let gas_used = client.gas_used(tx).await?;
        assert_eq!(gas_used, 21000);
        Ok(())
    }

    // #[tokio::test]
    // async fn test_header() -> eyre::Result<()> {
    //     let anvil = alloy_node_bindings::Anvil::new().block_time(1).chain_id(0).spawn();
    //     let rpc_url = anvil.endpoint();
    //     let client = ExecutionClient::new(rpc_url.parse().unwrap());
    //     let block = anvil.block().await?;
    //     let header = client.header(block).await?;
    //     assert_eq!(header.number, block);
    //     Ok(())
    // }
}
